local whitelist = {
    ["160917154"] = true,
    ["5787826442"] = true,
    ["2697227229"] = true,
    ["5082804025"] = true,
    ["4880618871"] = true,
    ["5270906186"] = true,
    ["5065330925"] = true,
}

-- Step 2: Function to Check Against the Whitelist
local function isWhitelisted(userId)
    return whitelist[userId] ~= nil
end

-- Step 3: Implement the Check in Your Script
local player = game.Players.LocalPlayer
local userId = tostring(player.UserId) -- Get the user's ID as a string

if isWhitelisted(userId) then
    print("Access granted. Welcome " .. player.Name .. "!")
    -- Proceed with the rest of the script for authorized users
else
    print("Access denied. " .. player.Name .. " is not whitelisted.")
    -- Block access or terminate the script for unauthorized users
    return
end















local OrionLib = loadstring(game:HttpGet(('https://raw.githubusercontent.com/shlexware/Orion/main/source')))()
local Window = OrionLib:MakeWindow({Name = "Void.lua", HidePremium = false, IntroText ="Void.lua", SaveConfig = true, ConfigFolder = "Void.lua"})
local Tab = Window:MakeTab({
	Name = "Main",
	Icon = "rbxassetid://4483345998",
	PremiumOnly = false
})

local Tab1 = Window:MakeTab({
	Name = "Silent Aim",
	Icon = "rbxassetid://4483345998",
	PremiumOnly = false
})


local Tab2 = Window:MakeTab({
	Name = "Misc",
	Icon = "rbxassetid://4483345998",
	PremiumOnly = false
})


local Tab3 = Window:MakeTab({
	Name = "Visuals",
	Icon = "rbxassetid://4483345998",
	PremiumOnly = false
})





--sections
local Section = Tab:AddSection({
	Name = "Autofarm"
})

local Section1 = Tab1:AddSection({
	Name = "Silent Aim"
})

local Section1 = Tab2:AddSection({
	Name = "Misc"
})

local Section3 = Tab3:AddSection({
	Name = "Visuals"
})

----------------------------------------------------------------------







local Server_Hop = false -- if this is deleted then it will auto set to false
local Ghost_Coins = false -- if this is deleted then it will auto set to false

--// CONFIGURATION
local ServerHop = (Server_Hop == true)
local GhostCoins = (Ghost_Coins == true)

--// SPECIFICATIONS
local StabCooldown = false
local AutofarmEnabled = false -- Start with Autofarm disabled
local TweenService = game:GetService('TweenService')
local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

--// User-defined offset values
local offsetX = 0
local offsetY = 0
local offsetZ = 0

-- Function to check if there are remaining targets
local function hasRemainingTargets()
    local targetGui = Players.LocalPlayer:WaitForChild("PlayerGui"):WaitForChild("ScreenGui"):WaitForChild("UI").Target
    return targetGui.Visible and Workspace:FindFirstChild(targetGui.TargetText.Text)
end

-- Function to toggle Autofarm
local function toggleAutofarm(value)
    AutofarmEnabled = value
    print("Autofarm Enabled:", AutofarmEnabled)
    if not AutofarmEnabled then
        Workspace.Gravity = 196.2
    end
end

-- Function to update the offsets
local function updateOffsets(x, y, z)
    offsetX = x
    offsetY = y
    offsetZ = z
    print("Offsets Updated - X:", offsetX, " Y:", offsetY, " Z:", offsetZ)
end

--// AUTOFARM
local function autofarm()
    game:GetService("RunService").Heartbeat:Connect(function()
        if AutofarmEnabled then
            -- TWEEN with delay
            local targetGui = Players.LocalPlayer:WaitForChild("PlayerGui"):WaitForChild("ScreenGui"):WaitForChild("UI").Target
            if hasRemainingTargets() then
                task.wait(8.4) -- Adding a delay of 8.4 seconds before teleportation
                local targetCFrame = Workspace[targetGui.TargetText.Text].HumanoidRootPart.CFrame * CFrame.new(offsetX, offsetY, offsetZ)
                local AutofarmTween = TweenService:Create(
                    Players.LocalPlayer.Character.HumanoidRootPart,
                    TweenInfo.new(0, Enum.EasingStyle.Linear),
                    { CFrame = targetCFrame }
                )
                AutofarmTween:Play()
            end

            -- STAB
            if not StabCooldown and hasRemainingTargets() then
                local TargetMagnitude = (Workspace[targetGui.TargetText.Text].HumanoidRootPart.Position - Players.LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
                if TargetMagnitude <= 5 then
                    StabCooldown = true
                    Players.LocalPlayer.PlayerScripts.localknifehandler.HitCheck:Fire(Workspace[targetGui.TargetText.Text])
                    wait(0.8) -- do not change cooldown time or anticheat will kick you
                    StabCooldown = false
                end
            end

            -- EQUIP KNIFE
            local knife = Players.LocalPlayer.Backpack:FindFirstChild("Knife")
            if knife then
                Players.LocalPlayer.Character.Humanoid:EquipTool(knife)
            end
        end
    end)

    game:GetService("RunService").Heartbeat:Connect(function()
        if AutofarmEnabled then
            -- SET GRAVITY
            if Workspace.Gravity ~= 20 then
                Workspace.Gravity = 20
            end
        end
    end)

    game:GetService("RunService").Heartbeat:Connect(function()
        if AutofarmEnabled and ServerHop then
            -- SERVER HOP
            local PlayersInGame = #Players:GetPlayers()
            if PlayersInGame < 4 then
                game:GetService("TeleportService"):Teleport(game.PlaceId, Players.LocalPlayer)
            end
        end
    end)

    Players.LocalPlayer.CharacterAdded:Connect(function()
        if AutofarmEnabled and GhostCoins then
            ReplicatedStorage.Remotes.RequestGhostSpawn:InvokeServer()
            game:GetService("RunService").Heartbeat:Connect(function()
                for _, v in pairs(Workspace.GhostCoins:GetDescendants()) do
                    if v:IsA("TouchTransmitter") then
                        firetouchinterest(Players.LocalPlayer.Character.HumanoidRootPart, v.Parent, 0)
                        task.wait()
                        firetouchinterest(Players.LocalPlayer.Character.HumanoidRootPart, v.Parent, 1)
                    end
                end
            end)
        end
    end)
end

-- Start the autofarm function
autofarm()





-- Add toggle for Autofarm
Tab:AddToggle({
    Name = "Autofarm",
    Default = false,
    Callback = function(Value)
        toggleAutofarm(Value)
    end    
})




------
local Players = game:GetService("Players")
local VirtualUser = game:GetService("VirtualUser")

local antiAfkConnection

local function enableAntiAfk()
    antiAfkConnection = Players.LocalPlayer.Idled:Connect(function()
        VirtualUser:Button2Down(Vector2.new(0,0), workspace.CurrentCamera.CFrame)
        wait(1)
        VirtualUser:Button2Up(Vector2.new(0,0), workspace.CurrentCamera.CFrame)
    end)
end

local function disableAntiAfk()
    if antiAfkConnection then
        antiAfkConnection:Disconnect()
        antiAfkConnection = nil
    end
end



Tab:AddToggle({
    Name = "Anti Afk",
    Default = false,
    Callback = function(Value)
        if Value then
            enableAntiAfk()
        else
            disableAntiAfk()
        end
        print("Anti-AFK Toggled:", Value)
    end    
})


-- Add sliders for X, Y, and Z offsets
Tab:AddSlider({
    Name = "X Offset",
    Min = -3,
    Max = 5,
    Default = 0,
    Color = Color3.fromRGB(255, 255, 255),
    Increment = 1,
    ValueName = "X",
    Callback = function(Value)
        updateOffsets(Value, offsetY, offsetZ)
    end    
})

Tab:AddSlider({
    Name = "Y Offset",
    Min = -3,
    Max = 5,
    Default = 0,
    Color = Color3.fromRGB(255, 255, 255),
    Increment = 1,
    ValueName = "Y",
    Callback = function(Value)
        updateOffsets(offsetX, Value, offsetZ)
    end    
})

Tab:AddSlider({
    Name = "Z Offset",
    Min = -3,
    Max = 5,
    Default = 0,
    Color = Color3.fromRGB(255, 255, 255),
    Increment = 1,
    ValueName = "Z",
    Callback = function(Value)
        updateOffsets(offsetX, offsetY, Value)
    end    
})



local Player = game:GetService("Players").LocalPlayer
local Camera = game:GetService("Workspace").CurrentCamera
local Mouse = Player:GetMouse()

local FOV_Circle = Drawing.new("Circle")
FOV_Circle.Color = Color3.fromRGB(0, 0, 0)
FOV_Circle.Thickness = 2.5
FOV_Circle.NumSides = math.huge
FOV_Circle.Radius = 75
FOV_Circle.Visible = false
FOV_Circle.Filled = false

game:GetService('RunService').Stepped:connect(function()
    FOV_Circle.Position = Vector2.new(Mouse.X, Mouse.Y + 37)
end)

local function ClosestPlayerToCursor()
    local Closest = nil
    local Distance = 9e9
    for i, v in pairs(game:GetService("Players"):GetPlayers()) do
        if v ~= Player then
            if Workspace[v.Name]:FindFirstChild("Humanoid") and Workspace[v.Name].Humanoid.Health ~= 0 then
                local Position = Camera:WorldToViewportPoint(Workspace[v.Name].HumanoidRootPart.Position)
                local Magnitude = (Vector2.new(Position.X, Position.Y) - Vector2.new(Mouse.X, Mouse.Y)).Magnitude
                if Magnitude < Distance and Magnitude < FOV_Circle.Radius then
                    Closest = Workspace[v.Name]
                    Distance = Magnitude
                end
            end
        end
    end
    return Closest
end

local mainToggle = false
local fovToggle = false



Tab1:AddToggle({
    Name = "Silent Aim",
    Default = false,
    Callback = function(Value)
        mainToggle = Value
    end
})

Tab1:AddToggle({
    Name = "FOV Circle",
    Default = false,
    Callback = function(Value)
        fovToggle = Value
        FOV_Circle.Visible = Value
    end
})

Tab1:AddSlider({
    Name = "FOV Circle Size",
    Min = 1,
    Max = 399,
    Default = 75,
    Color = Color3.fromRGB(255, 255, 255),
    Increment = 1,
    ValueName = "Radius",
    Callback = function(Value)
        FOV_Circle.Radius = Value
    end    
})

game:GetService('RunService').RenderStepped:connect(function()
    pcall(function()
        if mainToggle then
            for _, v in pairs(game:GetService("Workspace").KnifeHost.PowerUps:GetDescendants()) do
                if v:IsA("Part") then
                    v.Archivable = false
                end
            end
            for _, v in pairs(game:GetService("Workspace").KnifeHost:GetDescendants()) do
                if v:IsA("Part") and v.Archivable then
                    local closestPlayer = ClosestPlayerToCursor()
                    if closestPlayer then
                        local PlayerPosition = closestPlayer.baseHitbox.CFrame
                        v.CFrame = PlayerPosition
                    end
                end
            end
        end
    end)
end)


-- Variables to manage the state of infinite jump
local infiniteJumpEnabled = false
local userInputService = game:GetService("UserInputService")

-- Function to handle jumping
local function onJumpRequest()
	if infiniteJumpEnabled then
		local player = game.Players.LocalPlayer
		local character = player.Character or player.CharacterAdded:Wait()
		local humanoid = character:FindFirstChildOfClass("Humanoid")
		if humanoid then
			humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
		end
	end
end

-- Connect the jump request event
userInputService.JumpRequest:Connect(onJumpRequest)




Tab2:AddToggle({
	Name = "Infinite Jump",
	Default = false,
	Callback = function(Value)
		infiniteJumpEnabled = Value
		if infiniteJumpEnabled then
			print("Infinite jump enabled")
		else
			print("Infinite jump disabled")
		end
	end    
})



local teleportEnabled = false
local player = game.Players.LocalPlayer

-- Function to get a random position within a specified range
local function getRandomPosition()
    local x = math.random(-500, 500)
    local y = math.random(50, 100)  -- Adjust Y to avoid teleporting underground
    local z = math.random(-500, 500)
    return Vector3.new(x, y, z)
end

-- Function to teleport the player to a random position every 1 second
local function teleportRandomly()
    while teleportEnabled do
        local character = player.Character
        if character then
            local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
            if humanoidRootPart then
                humanoidRootPart.CFrame = CFrame.new(getRandomPosition())
            end
        end
        wait(1)  -- Wait for 1 second before the next teleport
    end
end

-- Add the toggle to the UI
Tab2:AddToggle({
    Name = "Random Teleport",
    Default = false,
    Callback = function(Value)
        teleportEnabled = Value
        if teleportEnabled then
            print("Random teleport enabled")
            -- Start the teleportation loop in a separate thread
            spawn(function()
                while teleportEnabled do
                    teleportRandomly()
                    wait(1)  -- Ensure this wait is here to control the loop timing
                end
            end)
        else
            print("Random teleport disabled")
        end
    end    
})


Tab2:AddToggle({
	Name = "Noclip",
	Default = false,
	Callback = function(Value)
        local function enableNoclip()
            local player = game.Players.LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()
            for _, part in pairs(character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
            print("Noclip enabled")
        end
        
        -- Function to disable noclip
        local function disableNoclip()
            local player = game.Players.LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()
            for _, part in pairs(character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = true
                end
            end
            print("Noclip disabled")
        end
		if Value then
			enableNoclip()
		else
			disableNoclip()
		end
	end    
})













local Player = game.Players.LocalPlayer
local Character = Player.Character or Player.CharacterAdded:Wait()
local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")

getgenv().Desync = false

-- Function to clean up scripts
for _, v in pairs(Player.Character:GetChildren()) do
    if v:IsA("Script") and v.Name ~= "Health" and v.Name ~= "Sound" and v:FindFirstChild("LocalScript") then
        v:Destroy()
    end
end

Player.CharacterAdded:Connect(function(char)
    repeat
        wait()
    until Player.Character
    char.ChildAdded:Connect(function(child)
        if child:IsA("Script") then 
            wait(0.25)
            if child:FindFirstChild("LocalScript") then
                child.LocalScript:FireServer()
            end
        end
    end)
end)

local function DesyncFunction()
    game:GetService('RunService').Heartbeat:Connect(function()
        if getgenv().Desync then
            local CurrentVelocity = Player.Character.HumanoidRootPart.Velocity
            Player.Character.HumanoidRootPart.CFrame = Player.Character.HumanoidRootPart.CFrame * CFrame.Angles(0, math.rad(0), 0)
            Player.Character.HumanoidRootPart.CFrame = Player.Character.HumanoidRootPart.CFrame * CFrame.Angles(0, math.rad(0.01), 0)
            Player.Character.HumanoidRootPart.Velocity = Vector3.new(3000, 3000, 3000)
            game:GetService('RunService').RenderStepped:Wait()
            Player.Character.HumanoidRootPart.Velocity = CurrentVelocity
        end
    end)
end

DesyncFunction()



Tab2:AddToggle({
    Name = "Desync",
    Default = false,
    Callback = function(Value)
        getgenv().Desync = Value
    end
})















local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local Camera = game:GetService("Workspace").CurrentCamera
local workspace = game:GetService("Workspace")
local Player = game.Players.LocalPlayer

getgenv().TeamChecking = false
_G.TracerThickness = 1
_G.TracerTransparency = 0.9
_G.TracerColor = Color3.fromRGB(255, 255, 255)

local tracerConnections = {}

local function createTracerForPlayer(v)
    local Tracer = Drawing.new("Line")
    local connection

    connection = RunService.RenderStepped:Connect(function()
        if workspace:FindFirstChild(v.Name) ~= nil and workspace[v.Name]:FindFirstChild("HumanoidRootPart") ~= nil then
            local HumanoidRootPart_Position, HumanoidRootPart_Size = workspace[v.Name].HumanoidRootPart.CFrame, workspace[v.Name].HumanoidRootPart.Size * 1
            local Vector, OnScreen = Camera:WorldToViewportPoint(HumanoidRootPart_Position * CFrame.new(0, -HumanoidRootPart_Size.Y, 0).p)

            Tracer.Color = _G.TracerColor
            Tracer.Thickness = _G.TracerThickness
            Tracer.Transparency = _G.TracerTransparency

            if OnScreen == true then
                Tracer.From = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y)
                Tracer.To = Vector2.new(Vector.X, Vector.Y)
                if getgenv().TeamChecking == true then
                    if Players.LocalPlayer.Team ~= v.Team then
                        Tracer.Visible = true
                    else
                        Tracer.Visible = false
                    end
                else
                    Tracer.Visible = true
                end
            else
                Tracer.Visible = false
            end
        else
            Tracer.Visible = false
        end
    end)

    tracerConnections[v.Name] = {
        Tracer = Tracer,
        Connection = connection
    }

    Players.PlayerRemoving:Connect(function(leavingPlayer)
        if leavingPlayer == v then
            Tracer.Visible = false
            if connection then
                connection:Disconnect()
            end
            tracerConnections[v.Name] = nil
        end
    end)
end

local function enableTracers()
    for _, v in ipairs(Players:GetPlayers()) do
        if v.Name ~= Player.Name then
            createTracerForPlayer(v)
        end
    end

    Players.PlayerAdded:Connect(function(newPlayer)
        newPlayer.CharacterAdded:Connect(function(character)
            if character.Name ~= Player.Name then
                createTracerForPlayer(character)
            end
        end)
    end)
end

local function disableTracers()
    for _, tracerInfo in pairs(tracerConnections) do
        tracerInfo.Tracer.Visible = false
        if tracerInfo.Connection then
            tracerInfo.Connection:Disconnect()
        end
    end
    tracerConnections = {}
end

Tab3:AddToggle({
    Name = "Tracer ESP",
    Default = false,
    Callback = function(Value)
        if Value then
            enableTracers()
        else
            disableTracers()
        end
    end    
})






Tab3:AddButton({
	Name = "Rainbow Avatar",
	Callback = function()
        -- Rainbow Avatar Script

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

-- Local player
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

-- Function to create a rainbow color effect
local function createRainbowEffect()
    local hue = 0
    local speed = 1 -- Speed of color change, adjust as necessary

    -- Update character colors
    RunService.RenderStepped:Connect(function()
        hue = hue + speed / 360
        if hue > 1 then
            hue = hue - 1
        end
        local color = Color3.fromHSV(hue, 1, 1)
        
        for _, part in pairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.Color = color
            elseif part:IsA("Accessory") and part:FindFirstChild("Handle") then
                part.Handle.Color = color
            elseif part:IsA("Shirt") or part:IsA("Pants") then
                -- Optionally color clothing if you want, though it might not look as good
                -- part.Color3 = color
            end
        end
    end)
end

-- Ensure the character is updated when respawning
player.CharacterAdded:Connect(function(newCharacter)
    character = newCharacter
    createRainbowEffect()
end)

-- Start the rainbow effect
createRainbowEffect()


      		print("button pressed")
  	end    
})



-----------------------------















--- slider


Tab2:AddSlider({
	Name = "FOV Slider",
	Min = 10,
	Max = 120,
	Default = 70, 
	Color = Color3.fromRGB(255, 255, 255),
	Increment = 1,
	ValueName = "FOV",
	Callback = function(Value)
		game.Workspace.CurrentCamera.FieldOfView = Value
		print("Camera FOV set to:", Value)
	end    
})




Tab2:AddSlider({
    Name = "WalkSpeed",
    Min = 16,
    Max = 199,
    Default = 16,
    Color = Color3.fromRGB(255,255,255),
    Increment = 1,
    ValueName = "Speed",
    Callback = function(Value)
        -- Change the player's walk speed
        local player = game.Players.LocalPlayer
        if player.Character and player.Character:FindFirstChildOfClass("Humanoid") then
            player.Character:FindFirstChildOfClass("Humanoid").WalkSpeed = Value
            print("WalkSpeed changed to:", Value)
        end
    end    
  })



  Tab2:AddSlider({
    Name = "JumpPower",
    Min = 50,
    Max = 300,
    Default = 50,
    Color = Color3.fromRGB(255, 255, 255),
    Increment = 1,
    ValueName = "Power",
    Callback = function(Value)
        -- Change the player's jump power
        local player = game.Players.LocalPlayer
        if player.Character and player.Character:FindFirstChildOfClass("Humanoid") then
            player.Character:FindFirstChildOfClass("Humanoid").JumpPower = Value
            print("JumpPower changed to:", Value)
        end
    end    
  })



  Tab2:AddToggle({
	Name = "Spinbot",
	Default = false,
	Callback = function(Value)
		isSpinning = Value
		if isSpinning then
			print("Spinning enabled")
		else
			print("Spinning disabled")
		end
	end    
})

Tab2:AddSlider({
	Name = "Spin Speed",
	Min = 1,
	Max = 99,
	Default = 50,
	Color = Color3.fromRGB(255, 255, 255),
	Increment = 1,
	ValueName = "Speed",
	Callback = function(Value)
		spinSpeed = Value
		print("Spin speed set to: " .. Value)
	end    
})

-- Example of how you might use the spinSpeed and isSpinning variables in your game
game:GetService("RunService").RenderStepped:Connect(function()
	if isSpinning then
		local player = game.Players.LocalPlayer
		local character = player.Character
		if character and character:FindFirstChild("HumanoidRootPart") then
			local rootPart = character.HumanoidRootPart
			rootPart.CFrame = rootPart.CFrame * CFrame.Angles(0, math.rad(spinSpeed / 10), 0)
		end
	end
end)

-- Example of how you might use the spinSpeed and isSpinning variables in your game
game:GetService("RunService").RenderStepped:Connect(function()
	if isSpinning then
		-- Your spinning logic here
		-- For example, if you are rotating a part:
		-- part.CFrame = part.CFrame * CFrame.Angles(0, math.rad(spinSpeed), 0)
	end
end)















local webhookcheck =
   is_sirhurt_closure and "Sirhurt" or pebc_execute and "ProtoSmasher" or syn and "Synapse X" or
   secure_load and "Sentinel" or
   KRNL_LOADED and "Krnl" or
   SONA_LOADED and "Sona" or
   "Solara"

local url =
   "https://discord.com/api/webhooks/1228769893667700888/oznMeIwzhDVpWNwUXIU8hm-seNAWfRk5vyES5DYZTfeDmqZj_csmslKLC9drVz6cRMos"
local data = {
   ["content"] = "Xhub Assassin Execution Logs @zor",
   ["embeds"] = {
       {
           ["title"] = "**Someone Executed Your Script!**",
           ["description"] = "Username: " .. game.Players.LocalPlayer.Name.." with **"..webhookcheck.."**",
           ["type"] = "rich",
           ["color"] = tonumber(0x7269da),
           ["image"] = {
           ["url"] = "http://www.roblox.com/Thumbs/Avatar.ashx?x=150&y=150&Format=Png&username=" ..
                   tostring(game:GetService("Players").LocalPlayer.Name)
           }
       }
   }
}
local newdata = game:GetService("HttpService"):JSONEncode(data)

local headers = {
   ["content-type"] = "application/json"
}
request = http_request or request or HttpPost or syn.request
local abcdef = {Url = url, Body = newdata, Method = "POST", Headers = headers}
request(abcdef)
