-- Intro UI
local ScreenGui = Instance.new("ScreenGui")
local Frame = Instance.new("Frame")
local TextLabel = Instance.new("TextLabel")
local UICorner = Instance.new("UICorner")

ScreenGui.Parent = game.CoreGui
ScreenGui.ResetOnSpawn = false

Frame.Parent = ScreenGui
Frame.BackgroundColor3 = Color3.new(0, 0, 0)
Frame.Position = UDim2.new(0.5, -150, 0.5, -50)
Frame.Size = UDim2.new(0, 300, 0, 100)

UICorner.Parent = Frame
UICorner.CornerRadius = UDim.new(0, 10)

TextLabel.Parent = Frame
TextLabel.BackgroundColor3 = Color3.new(1, 1, 1)
TextLabel.BackgroundTransparency = 1
TextLabel.Size = UDim2.new(1, 0, 1, 0)
TextLabel.Font = Enum.Font.SourceSansBold
TextLabel.Text = "Loading..."
TextLabel.TextColor3 = Color3.new(1, 1, 1)
TextLabel.TextScaled = true

local function introSequence()
    wait(2)
    TextLabel.Text = "Checking for whitelist..."
    wait(2)
    TextLabel.Text = "Game found: Assassin"
    wait(2)
    ScreenGui:Destroy()
end

introSequence()








local whitelist = {
    ["160917154"] = true,
    ["5787826442"] = true,
    ["2697227229"] = true,
    ["5082804025"] = true,
    ["4880618871"] = true,
    ["5270906186"] = true,
    ["5065330925"] = true,
    ["6186797376"] = true,
    ["6194285842"] = true,
    ["6192081505"] = true,
    ["4511505836"] = true,
    ["2551474547"] = true,
    ["2908327541"] = true,
    ["1483036312"] = true,
    ["187385437"] = true,
    ["7009389880"] = true
    ["351630757"] = true,
    ["5163927292"] = true,
}

-- Step 2: Function to Check Against the Whitelist
local function isWhitelisted(userId)
    return whitelist[userId] ~= nil
end

-- Step 3: Implement the Check in Your Script
local player = game.Players.LocalPlayer
local userId = tostring(player.UserId) -- Get the user's ID as a string

if isWhitelisted(userId) then
    print("Access granted. Welcome " .. player.Name .. "!")
    -- Proceed with the rest of the script for authorized users
else
    print("Access denied. " .. player.Name .. " is not whitelisted.")
    -- Block access or terminate the script for unauthorized users
    return
end













local Lib = loadstring(game:HttpGet("https://raw.githubusercontent.com/laagginq/ui-libraries/main/coastified/src.lua"))()
local Window = Lib:Window("Void.lua", "Buyer Build", Enum.KeyCode.RightShift)



local Autofarm = Window:Tab("Autofarm")
local Aiming = Window:Tab("Aiming")
local Misc = Window:Tab("Utilities")
local ESP = Window:Tab("Visuals")
local Desync = Window:Tab("Desync")





-----------------Buttons/Toggles/Sliders


local ServerHopEnabled = false
local CollectGhostCoins = false 

--// SPECIFICATIONS
local StabCooldown = false
local AutofarmEnabled = false 
local teleportDelay = 5 -- Default delay before teleportation
local teleportSpeed = 1 -- Default speed for teleporting (duration of tween)
local TweenService = game:GetService('TweenService')
local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

--// User-defined offset values
local offsetX = 0
local offsetY = 0
local offsetZ = 0

-- Function to check if there are remaining targets
local function hasRemainingTargets()
    local targetGui = Players.LocalPlayer:WaitForChild("PlayerGui"):WaitForChild("ScreenGui"):WaitForChild("UI").Target
    return targetGui.Visible and Workspace:FindFirstChild(targetGui.TargetText.Text)
end

-- Function to toggle Autofarm
local function toggleAutofarm(value)
    AutofarmEnabled = value
    print("Autofarm Enabled:", AutofarmEnabled)
    if not AutofarmEnabled then
        Players.LocalPlayer.Character.HumanoidRootPart.Anchored = false
    end
end

-- Function to toggle Ghost Coin collection
local function toggleCollectGhostCoins(value)
    CollectGhostCoins = value
    print("Collect Ghost Coins Enabled:", CollectGhostCoins)
end

-- Function to toggle Server Hop
local function toggleServerHop(value)
    ServerHopEnabled = value
    print("Server Hop Enabled:", ServerHopEnabled)
end

-- Function to update the offsets
local function updateOffsets(x, y, z)
    offsetX = x
    offsetY = y
    offsetZ = z
    print("Offsets Updated - X:", offsetX, " Y:", offsetY, " Z:", offsetZ)
end

-- Function to check if a position is safe
local function isPositionSafe(position)
    return position.Y > 0 -- Simple check to see if the character is above ground level
end

--// AUTOFARM
local function autofarm()
    game:GetService("RunService").Heartbeat:Connect(function()
        if AutofarmEnabled then
            -- TWEEN with delay
            local targetGui = Players.LocalPlayer:WaitForChild("PlayerGui"):WaitForChild("ScreenGui"):WaitForChild("UI").Target
            if hasRemainingTargets() then
                task.wait(teleportDelay) -- Adding a delay before teleportation
                local targetCFrame = Workspace[targetGui.TargetText.Text].HumanoidRootPart.CFrame * CFrame.new(offsetX, offsetY, offsetZ)
                Players.LocalPlayer.Character.HumanoidRootPart.Anchored = true -- Anchor the player to prevent falling
                Players.LocalPlayer.Character.HumanoidRootPart.CFrame = targetCFrame
                wait(0.1) -- Wait briefly to ensure the position is updated
                
                -- Unanchor if the position is safe
                if isPositionSafe(Players.LocalPlayer.Character.HumanoidRootPart.Position) then
                    Players.LocalPlayer.Character.HumanoidRootPart.Anchored = false
                else
                    -- Optionally handle unsafe teleport destination
                    print("Unsafe teleport destination detected!")
                end
            else
                if (Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart").Position - Workspace:FindFirstChild("FountainKnife").Position).Magnitude < 350 then
                    Players.LocalPlayer.Character.HumanoidRootPart.Anchored = true
                end
            end

            -- STAB
            if not StabCooldown and hasRemainingTargets() then
                local TargetMagnitude = (Workspace[targetGui.TargetText.Text].HumanoidRootPart.Position - Players.LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
                if TargetMagnitude <= 5 then
                    StabCooldown = true
                    Players.LocalPlayer.PlayerScripts.localknifehandler.HitCheck:Fire(Workspace[targetGui.TargetText.Text])
                    wait(0.74) -- do not change cooldown time or anticheat will kick you
                    StabCooldown = false
                end
            end
        end
    end)

    game:GetService("RunService").Heartbeat:Connect(function()
        if AutofarmEnabled and ServerHopEnabled then
            -- SERVER HOP
            local PlayersInGame = #Players:GetPlayers()
            if PlayersInGame < 4 then
                game:GetService("TeleportService"):Teleport(game.PlaceId, Players.LocalPlayer)
            end
        end
    end)

    game:GetService("RunService").Heartbeat:Connect(function()
        if CollectGhostCoins then
            for _, v in pairs(Workspace.GhostCoins:GetDescendants()) do
                if v:IsA("TouchTransmitter") then
                    firetouchinterest(Players.LocalPlayer.Character.HumanoidRootPart, v.Parent, 0)
                    task.wait()
                    firetouchinterest(Players.LocalPlayer.Character.HumanoidRootPart, v.Parent, 1)
                end
            end
        end
    end)

    Players.LocalPlayer.CharacterAdded:Connect(function()
        if AutofarmEnabled and Ghost_Coins then
            ReplicatedStorage.Remotes.RequestGhostSpawn:InvokeServer()
            game:GetService("RunService").Heartbeat:Connect(function()
                for _, v in pairs(Workspace.GhostCoins:GetDescendants()) do
                    if v:IsA("TouchTransmitter") then
                        firetouchinterest(Players.LocalPlayer.Character.HumanoidRootPart, v.Parent, 0)
                        task.wait()
                        firetouchinterest(Players.LocalPlayer.Character.HumanoidRootPart, v.Parent, 1)
                    end
                end
            end)
        end
    end)

    -- Toggle for Autofarm
    Autofarm:Toggle('Autokill', function(state)
        toggleAutofarm(state)
    end)

    -- Toggle for Collecting Ghost Coins
    Autofarm:Toggle('Collect Ghost Coins', function(state)
        toggleCollectGhostCoins(state)
    end)

    -- Toggle for Server Hop
    Autofarm:Toggle('Server Hop', function(state)
        toggleServerHop(state)
    end)

    -- Slider for Teleport Delay
    Autofarm:Slider('Teleport Delay', 1, 8.4, teleportDelay, function(value)
        teleportDelay = value
        print("Teleport Delay set to:", teleportDelay)
    end)

    -- Slider for Teleport Speed
    Autofarm:Slider('Teleport Speed', 0.1, 5, teleportSpeed, function(value)
        teleportSpeed = value
        print("Teleport Speed set to:", teleportSpeed)
    end)

    -- Slider for X Offset
    Autofarm:Slider('X Offset', -3, 5, offsetX, function(value)
        offsetX = value
        updateOffsets(offsetX, offsetY, offsetZ)
    end)

    -- Slider for Y Offset
    Autofarm:Slider('Y Offset', -3, 5, offsetY, function(value)
        offsetY = value
        updateOffsets(offsetX, offsetY, offsetZ)
    end)

    -- Slider for Z Offset
    Autofarm:Slider('Z Offset', -3, 5, offsetZ, function(value)
        offsetZ = value
        updateOffsets(offsetX, offsetY, offsetZ)
    end)

    -- Safety check for the void
    game:GetService("RunService").Heartbeat:Connect(function()
        if AutofarmEnabled then
            local rootPart = Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            if rootPart then
                if not isPositionSafe(rootPart.Position) then
                    print("Character in unsafe position, re-anchoring!")
                    rootPart.Anchored = true
                    -- Optional: Re-teleport to a safe position or respawn logic
                end
            end
        end
    end)
end

-- Start the autofarm function
autofarm()






-------------


local Player = game:GetService("Players").LocalPlayer
local Camera = game:GetService("Workspace").CurrentCamera
local Mouse = Player:GetMouse()

local FOV_Circle = Drawing.new("Circle")
FOV_Circle.Color = Color3.fromRGB(0, 0, 0)
FOV_Circle.Thickness = 2.5
FOV_Circle.NumSides = math.huge
FOV_Circle.Radius = 75
FOV_Circle.Visible = false
FOV_Circle.Filled = false
FOV_Circle.Transparency = 1

game:GetService('RunService').Stepped:connect(function()
    FOV_Circle.Position = Vector2.new(Mouse.X, Mouse.Y + 37)
end)

local function ClosestPlayerToCursor()
    local Closest = nil
    local Distance = 9e9
    for _, v in pairs(game:GetService("Players"):GetPlayers()) do
        if v ~= Player then
            if Workspace[v.Name]:FindFirstChild("Humanoid") and Workspace[v.Name].Humanoid.Health ~= 0 then
                local Position = Camera:WorldToViewportPoint(Workspace[v.Name].HumanoidRootPart.Position)
                local Magnitude = (Vector2.new(Position.X, Position.Y) - Vector2.new(Mouse.X, Mouse.Y)).Magnitude
                if Magnitude < Distance and Magnitude < FOV_Circle.Radius then
                    Closest = Workspace[v.Name]
                    Distance = Magnitude
                end
            end
        end
    end
    return Closest
end

local mainToggle = false
local fovToggle = false
local filledFOVToggle = false

Aiming:Toggle('Silent Aim', function(state)
    mainToggle = state
end)

Aiming:Toggle('FOV Circle', function(state)
    fovToggle = state
    FOV_Circle.Visible = state
end)

Aiming:Toggle('Filled FOV', function(state)
    filledFOVToggle = state
    FOV_Circle.Filled = state
end)

Aiming:Slider('Fov Size', 1, 399, 75, function(value)
    FOV_Circle.Radius = value
end)

Aiming:Slider('FOV Circle Thickness', 1, 10, 2.5, function(value)
    FOV_Circle.Thickness = value
end)

Aiming:Slider('FOV Circle Transparency', 0, 1, 5, function(value)
    FOV_Circle.Transparency = value
end)

Aiming:Colorpicker('FOV Circle Color', Color3.fromRGB(0, 0, 0), function(color)
    FOV_Circle.Color = color
end)

game:GetService('RunService').RenderStepped:connect(function()
    pcall(function()
        if mainToggle then
            for _, v in pairs(game:GetService("Workspace").KnifeHost.PowerUps:GetDescendants()) do
                if v:IsA("Part") then
                    v.Archivable = false
                end
            end
            for _, v in pairs(game:GetService("Workspace").KnifeHost:GetDescendants()) do
                if v:IsA("Part") and v.Archivable then
                    local closestPlayer = ClosestPlayerToCursor()
                    if closestPlayer then
                        local PlayerPosition = closestPlayer.baseHitbox.CFrame
                        v.CFrame = PlayerPosition
                    end
                end
            end
        end
    end)
end)





-- Default values for WalkSpeed and JumpPower
local defaultWalkSpeed = 16
local defaultJumpPower = 50

-- Function to update WalkSpeed
local function setWalkSpeed(value)
    local humanoid = game.Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid.WalkSpeed = value
        print("WalkSpeed set to:", value)
    else
        warn("Humanoid not found.")
    end
end

-- Function to update JumpPower
local function setJumpPower(value)
    local humanoid = game.Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid.JumpPower = value
        print("JumpPower set to:", value)
    else
        warn("Humanoid not found.")
    end
end

-- Example of using sliders to update WalkSpeed and JumpPower
Misc:Slider('WalkSpeed', 0, 100, defaultWalkSpeed, function(value)
    setWalkSpeed(value)
end)

Misc:Slider('JumpPower', 0, 200, defaultJumpPower, function(value)
    setJumpPower(value)
end)





local spinning = false
local spinSpeed = 0

-- Function to start and stop spinning
local function spinCharacter()
    local player = game.Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    
    while spinning do
        if character then
            character:SetPrimaryPartCFrame(character.PrimaryPart.CFrame * CFrame.Angles(0, math.rad(spinSpeed), 0))
        end
        wait(0.1) -- Adjust the wait time as needed for smoother spinning
    end
end

-- Toggle for Spinning
Misc:Toggle('Spinbot', function(state)
    if state then
        spinning = true
        spinCharacter()
    else
        spinning = false
    end
end)

-- Slider for Spin Speed
Misc:Slider('Spin Speed', 0, 100, 0, function(value)
    spinSpeed = value
    print("Spin Speed set to: " .. value)
end)






local Players = game:GetService("Players")
	local VirtualUser = game:GetService("VirtualUser")
	
	local antiAfkConnection
	
	local function enableAntiAfk()
		antiAfkConnection = Players.LocalPlayer.Idled:Connect(function()
			VirtualUser:Button2Down(Vector2.new(0, 0), workspace.CurrentCamera.CFrame)
			wait(1)
			VirtualUser:Button2Up(Vector2.new(0, 0), workspace.CurrentCamera.CFrame)
		end)
	end
	
	local function disableAntiAfk()
		if antiAfkConnection then
			antiAfkConnection:Disconnect()
			antiAfkConnection = nil
		end
	end
	
	-- Use Test:Toggle instead of Tab:AddToggle
	Misc:Toggle('Anti Afk', function(state)
		print(state)
		if state then
			enableAntiAfk()
		else
			disableAntiAfk()
		end
		print("Anti-AFK Toggled:", state)
	end)

--------- Esp


local Players = game:GetService("Players")
local HighlightService = {} -- Table to manage highlights
local isEnabled = false -- Initially set to false
local outlineColor = Color3.fromRGB(173, 216, 230)

-- Function to add a highlight to a player character
local function highlightPlayer(character)
    -- Check if the highlight already exists and destroy it if it does
    if character:FindFirstChild("Highlight") then
        character.Highlight:Destroy()
    end
    
    -- Create a new highlight instance
    local highlight = Instance.new("Highlight")
    highlight.FillTransparency = 1 -- Make sure the fill is fully transparent
    highlight.OutlineColor = outlineColor -- Set the current outline color
    highlight.Name = "Highlight"
    highlight.Parent = character
    HighlightService[character] = highlight
    print("Highlight added to:", character.Name)
end

-- Function to handle when a player's character is added
local function onCharacterAdded(character)
    print("Character added:", character.Name)
    if isEnabled then
        highlightPlayer(character)
    end
end

-- Function to handle when a player joins the game
local function onPlayerAdded(player)
    print("Player added:", player.Name)
    -- Connect the function to the player's CharacterAdded event
    player.CharacterAdded:Connect(onCharacterAdded)
    
    -- If the player already has a character, highlight it if enabled
    if player.Character and isEnabled then
        highlightPlayer(player.Character)
    end
end

-- Function to handle toggling ESP
local function toggleESP(state)
    isEnabled = state
    print("Highlighting enabled:", isEnabled)
    
    if not isEnabled then
        -- Remove highlights from all characters
        for character, highlight in pairs(HighlightService) do
            if highlight and highlight.Parent then
                highlight:Destroy()
                print("Highlight removed from:", character.Name)
            end
        end
        -- Clear the HighlightService table
        HighlightService = {}
    else
        -- Add highlights to all players
        for _, player in pairs(Players:GetPlayers()) do
            if player.Character then
                highlightPlayer(player.Character)
            end
        end
    end
end

-- Function to handle changing the color
local function changeColor(color)
    outlineColor = color
    print("Outline color changed to:", color)
    
    -- Update the color of all existing highlights
    for character, highlight in pairs(HighlightService) do
        if highlight and highlight.Parent then
            highlight.OutlineColor = color
            print("Color updated for:", character.Name)
        end
    end
end

-- Connect the function to the PlayerAdded event
Players.PlayerAdded:Connect(onPlayerAdded)

-- Highlight all existing players if the toggle is enabled
for _, player in pairs(Players:GetPlayers()) do
    player.CharacterAdded:Connect(onCharacterAdded)
    if player.Character then
        highlightPlayer(player.Character)
    end
end

-- ESP Toggle Function
ESP:Toggle('Player Chams', function(state)
    toggleESP(state)
end)

-- ESP Color Picker Function
ESP:Colorpicker("Cham Colour", Color3.fromRGB(0, 0, 0), function(color)
    changeColor(color)
end)


-- --- Desync

local Player = game.Players.LocalPlayer
local Character = Player.Character or Player.CharacterAdded:Wait()
local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")

getgenv().Desync = false
getgenv().DesyncAngles = {X = 0, Y = 0.01, Z = 0}

for _, v in pairs(Player.Character:GetChildren()) do
    if v:IsA("Script") and v.Name ~= "Health" and v.Name ~= "Sound" and v:FindFirstChild("LocalScript") then
        v:Destroy()
    end
end

Player.CharacterAdded:Connect(function(char)
    repeat
        wait()
    until Player.Character
    char.ChildAdded:Connect(function(child)
        if child:IsA("Script") then 
            wait(0.25)
            if child:FindFirstChild("LocalScript") then
                child.LocalScript:FireServer()
            end
        end
    end)
end)

local function DesyncFunction()
    game:GetService('RunService').Heartbeat:Connect(function()
        if getgenv().Desync then
            local CurrentVelocity = Player.Character.HumanoidRootPart.Velocity
            Player.Character.HumanoidRootPart.CFrame = Player.Character.HumanoidRootPart.CFrame * CFrame.Angles(0, math.rad(getgenv().DesyncAngles.X), 0)
            Player.Character.HumanoidRootPart.CFrame = Player.Character.HumanoidRootPart.CFrame * CFrame.Angles(0, math.rad(getgenv().DesyncAngles.Y), 0)
            Player.Character.HumanoidRootPart.CFrame = Player.Character.HumanoidRootPart.CFrame * CFrame.Angles(0, math.rad(getgenv().DesyncAngles.Z), 0)
            Player.Character.HumanoidRootPart.Velocity = Vector3.new(3000, 3000, 3000)
            game:GetService('RunService').RenderStepped:Wait()
            Player.Character.HumanoidRootPart.Velocity = CurrentVelocity
        end
    end)
end

DesyncFunction()

Desync:Toggle('Desync', function(state)
    print(state)
    getgenv().Desync = state
end)

-- Adding sliders for angles
Desync:Slider('Angle X', -180, 180, getgenv().DesyncAngles.X, function(Value)
    getgenv().DesyncAngles.X = Value
    print('Angle X:', Value)
end)

Desync:Slider('Angle Y', -180, 180, getgenv().DesyncAngles.Y, function(Value)
    getgenv().DesyncAngles.Y = Value
    print('Angle Y:', Value)
end)

Desync:Slider('Angle Z', -180, 180, getgenv().DesyncAngles.Z, function(Value)
    getgenv().DesyncAngles.Z = Value
    print('Angle Z:', Value)
end)


    ------ Nothing Below 



local toggleState = false  -- Initial state of the toggle

-- Function to fire the ThrowKnife remote event with a delay
local function fireThrowKnifeWithDelay()
    local args = {
        [1] = Vector3.new(196.77053833007812, 7.5, 40.80939865112305),
        [2] = 0,
        [3] = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1)
    }
    
    while true do
        if toggleState then
            -- Fire the ThrowKnife remote event
            game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("ThrowKnife"):FireServer(unpack(args))
        end
        
        -- Adjust the delay (in seconds) between each firing
        wait(1)  -- Change the delay time as needed
    end
end

-- Function to toggle the state
local function toggleEnabled(state)
    toggleState = state
    print("ThrowKnife firing:", toggleState)
end

-- Example usage of the toggle
Misc:Toggle('Autothrow', function(state)
    toggleEnabled(state)
end)

-- Call the function to start the loop initially
fireThrowKnifeWithDelay()
